1. Design Patterns
	a. After Creating class with singleton pattern, how can we break that pattern and how to prevent breaking of such way. 
2. SOLID principles

----Basic----
1. OOPS Concepts
	Encapsulation: All attributes should be private and the set/get methods should be public. (Constructor usage is not involved in encapsulation)
	Inheritance: To re-use all the characteristics of Parent. We can use Interface/Class for this. we use implements/extends 
	respectively.   
			Ex: In serice and Dao, mostly use have interfaces and their implementation classes.
				Parent Class reference can hold child class object.
	Polymorphism: Single(poly) method can have multiple (morph) implementations 
				-- Overloading (Static -- compile time): same method name with different no. of arguments. Here also, implementation will be different, but definitely the no./type of arguments should be different
				-- Over-riding (Dynamic -- run time) : method signature should be same, but different implementation in Parent and Child.
						1. If the return type in interface method is of parent type, then you can return either parent/child type in implementation method.
		Dynamic polymorphism: In DAO, we need service class, but we won't inject serviceImpl class, instead wee inject service interface. this is called run-time/dynamic polymorphism.
	Abstraction: Hiding the implementation to the end-user, displaying only the method name to them.
		1. Abstraction can be achieved with either abstract classes or interfaces.	
		2. Abstract classes should be used primarily for objects that are closely related, whereas interfaces are best suited for providing a common functionality to unrelated classes
2. please take time and explore some problem statements reg Inheritance OR even entire OOPS
3. Explain Exception Hierarchy in Inheritance.
	If parent's method is throwing exception, its optional for child to throw or not.
	But if child is throwing exception, definitely parent needs to throw the exception
4. Parent - Child override scenario
	1. let's say a method is available in both parent and child. -- in the driver class, the method exxecuted will be based on whose instance we created. (Parent ref can hold child instance but vice-versa is not possible)
	2. Let's say the method is available only in parent, we didn't override in child. But we create child obj with parent ref, the method executed will be of parent without any comiplation error, that's where the inheritance concept lies. if the child has that property or behaviour, the driver uses it or else it takes from parent.
	
5. Can we over-ride static and private method ?
	Ans: ************************NO*********************** -- as simple as that, both static and private are kindof personal things.
		1. As private method visibility itself is confined to that particular class, we cannot override it.
		2. for static -- the compilation error we get is -- "Method does not override methos from its superclass".
			However, the child class can have a static method with same name as the static method from parent. only when we provide @override, the error comes.
6. What is the difference of Java7 and Java8 interface ?
	Java 7 -- we can only define abstract classes in interface.
	Java 8 -- along with abstract (which only has definition), we can have default and static methods also, which have implementation 
		purpose of default : 
				1. is to not mandate implementation classes to override it. they'll have flexibility to override or not.
				2. This will be helpful to add new method into interface, as all implementation classes need not implement it mandatorily like earlier in Java7. kind of Virtual extension, as the name of Default/Virtual Extension Method contains.
		purpose of static : Utility methods can be made static. this is BETTER ALTERNATIVE to UTIL classes. 
			Class is costly compared to interface. Basically, interfaces let the compiler know the expected behavior of the object.
			
	Java 8 Functional Interface : This should have only one abstract method. there is no restriction on no. of default and static methods., where as normal interface can have any no. of abstract methods. @FunctionalInterface annotation is optional
	
	6.1 : Is abstract keyword mandatory from Java8 ?
		Ans : ***********NO**********. 
			till Java7, as there are only abstract methods in Interface, it is optional. However its still optional in Java8 and above aswell. Because abstract methods won't have implementation, it can be differentiated from default and static methods of interface easily.
	6.2 : Any Change in interface variables before and after Java8 ?
		Ans : ***********NO**********. 
			before adn after Java 8, all the variables are by default, PUBLIC STATIC and FINAL.
	6.3 : Can we declare private methods in Interface in Java8 ?
		Ans : ***********NO**********. 
			It is available from Java 9 onwards.
	6.4 :  normal Note: Classes CANNOT HAVE DEFAULT methods
	6.5 : Object class' methods cannot be defined as default methods in interface as they're already available by default to all classes.
	6.6 : IMPORTANT. How the Diamond access problem is solved in Java8 interfaces ?
		
		
		Theory : 
			Earlier in Java7, as only abstract methods are available, there is no problem in a class implementing multiple interfaces. Because, the class will implement it's own logic.
			
			Now, as Default methods are introduced in Java8 interfaces, a class implementing two interfaces which has same method in both of them, will have ambiguity (Diamond problem). like which implementation to take in implementation class (Child)
			
			Solution: The class should override that method and can
				i.  provide it's own logic
				ii. call either of the interface's method using <InterfaceName>.super.<methodName>();
7. What is final, finally and finalize ?
	final : keyword -- used on variables if you do not want them to be reassigned.
	finally : block -- used for manual cleanup/close connections(through code) activity
		-- used in try{} finally{} or try{} catch{} and then finally {}.
	finalize : method -- when we call System.gc();  this method is called internally by JVM., only if some object is assigned to null.
				-- Otherwise, finalize method won't be called. To understand it better ,we can override the finalize method which exists in Object class.
				-- Here to override finalize method, wee don't need to extend it to Object class, as by default all classes are childs of Object class.
8. What are equals and hashCode methods and their contract ?
	hashcode method : to generate unique code through which we can differentiate objects and identify unique obj.
	equals method : used to compare two objects based on their content.
	
	NOTE : Its not mandatory that if two Object's hashcode is same, their content is same and doesn't necesarily mean they are equal based on equals method.
	
	Contract: 
			In the case, we do not override equals and hashcode, two objects with all fields containing equal values are also treated as different. to get demonstration, create a pojo without equals and hashcode, create a set and add two objects with different reference, but with equal values for all fields. and print the set to see two objects added into that.
			
			In order to avoid that, WE HAVE TO OVERRIDE BOTH EQUALS and HASHCODE methods and make sure their implementation is in such a way that, two equal object (based on equals method) should return same hashcode. and two unequal should return diff hashcode.
			
			refer : Hashmap_InternalWorking.docx in HelpFiles in jav8e2e project
9. What is Exception and its Hierarchy ? -- refer ExceptionHierarchy.png in HelpFiles > Interview_Questions
	try to rem as many exceptions as possible.
10. Why Checked exceptions are also called as compile time exception, does it occur in compile time ?
	Ans : *********NO**********
	
	Explanation : that is just a naming convention, however checked exception won't occur in compile time. all the exceptions are raised at run time only.
	
	Whatttt ?? Seriously ????
	
	Yes, even the checked exceptions occurs at run-time, however, compiler gives a warning to handle these exceptions. may be why they're called as compile time exceptions, not because they'll be raised during compile time.
	
	
	Learn Deep on it.
11. Is it possible that the ‘finally’ block will not be executed? If yes then list the case.
	
	Yes, the finally block always gets executed unless there is an abnormal program termination either resulting from a JVM crash or from a call to System. exit().
12. Apart from the security aspect, what are the reasons behind making strings immutable in Java?

	The String is immutable in Java because of the security, synchronization and concurrency, caching, and class loading. 
	The reason of making string final is to destroy the immutability and to not allow others to extend it. 
	The String objects are cached in the String pool, and it makes the String immutable.
	
13. Why is String immutable in Java.
	
	In the String constant pool, a String object is likely to have one or many references. If several references point to the same String without even knowing it, it would be bad if one of the references modified that String value. That’s why String objects are immutable.
	
	https://www.geeksforgeeks.org/java-string-is-immutable-what-exactly-is-the-meaning/#:~:text=In%20the%20String%20constant%20pool,why%20String%20objects%20are%20immutable.
14. What is String intern method ?

	It is used to return string from memory if it is created by a new keyword. It creates an exact copy of the heap string object in the String Constant Pool.
	
	Background : 
	1. we know when strings are created as below, first it is created in StringConstantPool SCP and second time, the reference is returned for the same String.
	
	String s1 = "Java";
	String s2 = "Java";   s1==s2 -> true
	
	2. However when they are created this way, two unique objects are created in Heap outside the SCP.
	
	String s1 = new String("Java");
	String s2 = new String("Java");		s1==s2 -> false
	
	3. If sometime, we might need to understand the value is equal of two objects, we can call intern() method on them.
	
	String s1 = new String("Java").intern();
	String s2 = new String("Java").intern();	s1==s2 -> true
15. In Java, static as well as private method overriding is possible. Comment on the statement.

	1. METHOD HIDING: 	
		You cannot override a private or static method in Java. If you create a similar method with same return type and same method arguments in child class then it will hide the super class method; this is known as method hiding. 
		
		Method hiding can be defined as, "if a subclass defines a static method with the same signature as a static method in the super class, in such a case, the method in the subclass hides the one in the superclass." The mechanism is known as method hiding. It happens because static methods are resolved at compile time.
	
	2. Similarly, you cannot override a private method in sub class because it's not accessible there.
		
		A private method is automatically final and hidden. You are therefore not able to override any private methods
		
16. Can we write multiple classes in one Java file

	1. In general, Java has a main public class with a name that should match with the Java class file name and it calls other classes from this main class.
	2. Why we can not write multiple public classes in single .java file?
	
	So the reason behind keeping one public class per source file is to actually make the compilation process faster because it enables a more efficient lookup of source and compiled files during linking (import statements).
	
	3. that means we can have any number of classes inside a java file, but only one public class.
17. What happens if the static modifier is not included in the main method signature in Java

	Ans :: 
		If you don't add the 'static' modifier in your main method definition, the compilation of the program will go through without any issues but when you'll try to execute it, a "NoSuchMethodError" error will be thrown. 
		
		Now, this happens because when you execute a JAVA program, the JVM needs to know the sequence of execution i.e. needs to have a driver code, and what to execute. Any method that is non-static hasn't been allocated memory by default, on compilation. If no memory has been allocated to the method, in the eyes of the JVM, it doesn't exist, despite the compilation. And when the JVM searches for the 'main' function to execute, it isn't able to find it. This is why you'll get such an error. 
18. What do you understand by Object Cloning and how do you achieve it in Java?
			
	we can clone using clone() method, using == operator jsut assigns a reference, not the actual object.
	
	parent needs to implements Cloneable and override the clone method.
	Child/Driver needs to extend and then clone can be called on the objects of child to create copies.
	
	Deep copy and shallow copy :  	https://www.geeksforgeeks.org/clone-method-in-java-2/#:~:text=Object%20cloning%20refers%20to%20the,corresponding%20fields%20of%20this%20object.&text=In%20Java%2C%20there%20is%20no,a%20copy%20of%20an%20object.
19. Why do we need Serialisation : 

	Serialization in Java allows us to convert an Object to stream that we can send over the network or save it as file or store in DB for later usage. 
	Deserialization is the process of converting Object stream to actual Java Object to be used in our program.

	https://www.digitalocean.com/community/tutorials/serialization-in-java
	
	How do we serialise classes ?
	implement java.io.Serializable Interface.
	
	serialVersionUID :: ??
	The serialVersionUID attribute is an identifier that is used to serialize/deserialize an object of a Serializable class.
	
	More on Serialization : https://www.digitalocean.com/community/tutorials/serialization-in-java

20. Transient keyword : variable modifier
	We can use transient on fields of a class to make them ineligible for serialization.
	
	1. transient is a variables modifier used in serialization. At the time of serialization, if we don’t want to save value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type.
	2. transient and static : Since static fields are not part of state of the object, there is no use/impact of using transient keyword with static variables. However there is no compilation error.
	3. transient and final : final variables are directly serialized by their values, so there is no use/impact of declaring final variable as transient. There is no compile-time error though.
	

21. What is Marker Interface ? any example ?  https://www.geeksforgeeks.org/marker-interface-java/
	
	It is an empty interface (no field or methods). Examples of marker interface are Serializable(java.io), Cloneable (java.lang package) and Remote interface ( java.rmi). All these interfaces are empty interfaces.
	
	Cloneable : 
		1. any class that implements this interface is legal for clone() method to make a field-for-field copy of instances of that class. 
		2. Invoking Object’s clone method on an instance of the class that does not implement the Cloneable interface results in an exception CloneNotSupportedException being thrown
	Serializable interface : 
		1. It is used to make an object eligible for saving its state into a file. This is called Serialization. 
		2. Classes that do not implement this interface will not have any of their state serialized or deserialized
	Remote:
		1. A remote object is an object which is stored at one machine and accessed from another machine. So, to make an object a remote object, we need to flag it with Remote interface. 
		2. Here, Remote interface serves to identify interfaces whose methods may be invoked from a non-local virtual machine.
		3. Any object that is a remote object must directly or indirectly implement this interface. RMI (Remote Method Invocation) provides some convenience classes that remote object implementations can extend which facilitate remote object creation.
	
	Why Marker interfaces :	
		Marker interface is used as a tag that inform the Java compiler by a message so that it can add some special behavior to the class implementing it.
	
	
	